#!/usr/bin/python2.6
"""%prog [options]

Submit a UI job and connect to it when it begins to run.
"""

import logging
import os
import sys

from collections import namedtuple
from contextlib import contextmanager
from optparse import OptionParser, make_option as Opt
from shutil import rmtree
from subprocess import Popen, PIPE
from tempfile import mkdtemp
from time import sleep

RUNTIME = 600
SLEEP = "/bin/sleep"

log = logging.getLogger(__name__)

def main():
    optparser = OptionParser(usage=__doc__, option_list=options)
    (opts, args) = optparser.parse_args()

    verbose = int(opts.verbose)
    if verbose >= 0:
        log.level = max(1, logging.WARNING - (10 * verbose))
        log.addHandler(logging.StreamHandler())


    SUBMIT["executable"] = SLEEP
    SUBMIT["arguments"] = '"%s"' % RUNTIME
    x509 = os.environ.get("X509_USER_PROXY", "/tmp/x509up_u%s" % os.getuid())
    if os.path.exists(x509):
        SUBMIT["X509UserProxy"] = x509

    cmscvmfs = "/cvmfs/cms.hep.wisc.edu"
    attr = Popen(["attr", "-q", "-g revision", cmscvmfs], stdout=PIPE, stderr=PIPE)
    cvmfsrev = attr.stdout.read()
        
    SUBMIT["requirements"] += " && TARGET.UWCMS_CVMFS_Revision >= %s" % (
        cvmfsrev if attr.returncode == 0 else "0")

    with tempdir() as tmp:
        with open(os.path.join(tmp, "submit"), 'w') as submit:
            log.debug("writing submit file to %s", submit.name)
            template(submit, SUBMIT.items())
            submit = submit.name

        log.info("submitting UI job")
        condor_submit = Popen(["condor_submit", submit], stdout=PIPE, stderr=PIPE)
        stdout, stderr = condor_submit.communicate()
        log.debug("condor_submit returned %d", condor_submit.returncode)

        if condor_submit.returncode != 0:
            sys.stderr.write("condor_submit returned %d\n" % condor_submit.returncode)
            sys.stdout.write(stdout)
            sys.stderr.write(stderr)
            return condor_submit.returncode
        
        log.info("waiting for job to begin to run")
        with open(os.path.join(tmp, "log")) as logfile:
            jobid = monitor(tail(logfile))

        log.info("connecting to job")
        condor_ssh_to_job = Popen(["condor_ssh_to_job", jobid])
        condor_ssh_to_job.wait()

    # We don't really care if condor_rm fails here.
    condor_rm = Popen(["condor_rm", jobid], stdout=PIPE, stderr=PIPE)
    condor_rm.communicate()

    return condor_ssh_to_job.returncode

options = [
    Opt("-v", "--verbose", default=0, help="set logging level to VERBOSE"),
]

def tail(file):
    while True:
        line = file.readline()
        if not line:
            sleep(.2)
        else:
            yield line

def monitor(stream):
    for line in stream:
        if line == "...\n":
            continue
        record = Record(*line.split(None, 4))
        log.debug("%s %s", record.id, record.message.rstrip())
        if "Job executing" in record.message:
            return record.id.strip("()")

@contextmanager
def tempdir(*args, **kwargs):
    tmp = mkdtemp(*args, **kwargs)
    log.debug("created temporary directory %s", tmp)
    os.chdir(tmp)

    try:
        yield tmp
    finally:
        log.debug("cleaning up temporary directory %s", tmp)
        rmtree(tmp)

def template(out, context):
    out.write("\n".join("%s = %s" % (k, v) for k, v in context))
    out.write("\n")
    out.write("queue\n")

SUBMIT = dict(
    universe="vanilla",
    notification="never",
    log="log",
    transfer_executable="false",
    should_transfer_files="true",
    when_to_transfer_output="on_exit",
    getenv="true",
    requirements=(
        'TARGET.Arch == "X86_64" && '
        'TARGET.HasAFS_OSG && IsSlowSlot=!=true'
    ),
)

Record = namedtuple("Record", "entry id date time message")

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit()
