#!/usr/bin/python2.6
"""%prog [options]

Submit a UI job and connect to it when it begins to run.
"""

import logging
import os
import sys

from collections import namedtuple
from contextlib import contextmanager
from optparse import OptionParser, make_option as Opt
from pwd import getpwuid
from shutil import rmtree
from subprocess import Popen, PIPE
from tempfile import mkdtemp
from time import sleep

RUNTIME = 600
SLEEP = "/bin/sleep"

log = logging.getLogger(__name__)

def main():
    optparser = OptionParser(usage=__doc__, option_list=options)
    (opts, args) = optparser.parse_args()

    verbose = int(opts.verbose)
    if verbose >= 0:
        log.level = max(1, logging.WARNING - (10 * verbose))
        log.addHandler(logging.StreamHandler())

    SUBMIT["executable"] = SLEEP
    SUBMIT["arguments"] = RUNTIME

    hascvmfs(SUBMIT)
    x509 = hasx509(SUBMIT)

    if x509:
        glexecargs = ["-t", "glexec", os.environ.get("SHELL", "/bin/bash")]
        if args:
            glexecargs.append("-c")
        os.environ["GLEXEC_CLIENT_CERT"] = os.path.basename(x509)
        args = glexecargs + args

    prefix = "%s-%s-" % ("clusterui", getpwuid(os.getuid())[0])
    preserve = opts.no_submit or opts.preserve
    submitdir = os.path.abspath(opts.submit_dir) if opts.submit_dir else None
    with tempdir(cleanup=not preserve, dir=submitdir, prefix=prefix) as tmp:
        with open(os.path.join(tmp, "submit"), 'w') as submit:
            log.debug("writing submit file to %s", submit.name)
            template(submit, SUBMIT.items())
            submit = submit.name

        if opts.no_submit:
            sys.stdout.write("prepared job in %s\n" % tmp)
            return 0

        log.info("submitting UI job")
        condor_submit = Popen(["condor_submit", submit], stdout=PIPE, stderr=PIPE)
        stdout, stderr = condor_submit.communicate()
        log.debug("condor_submit returned %d", condor_submit.returncode)

        if condor_submit.returncode != 0:
            sys.stderr.write("condor_submit returned %d\n" % condor_submit.returncode)
            sys.stdout.write(stdout)
            sys.stderr.write(stderr)
            return condor_submit.returncode
        
        log.info("waiting for job to begin to run")
        with open(os.path.join(tmp, "log")) as logfile:
            jobid = monitor(tail(logfile))

        log.info("connecting to job")
        log.debug("running condor_ssh_to_job %s %s", jobid, 
            ' '.join(repr(x) for x in args))
        condor_ssh_to_job = Popen(["condor_ssh_to_job", jobid] + args)
        condor_ssh_to_job.wait()

    # We don't really care if condor_rm fails here.
    condor_rm = Popen(["condor_rm", jobid], stdout=PIPE, stderr=PIPE)
    condor_rm.communicate()

    return condor_ssh_to_job.returncode

options = [
    Opt("-v", "--verbose", default=0, help="set logging level to VERBOSE"),
    Opt("-d", "--submit-dir", default=None,
        help="create submit directory under SUBMIT_DIR"),
    Opt("-n", "--no-submit", default=False, action="store_true",
        help="don't actually submit the UI job (implies -p)"),
    Opt("-p", "--preserve", default=False, action="store_true",
        help="preserve temporary job directory"),
]

def glexec(submit):
    """This works, but:

    *   the job is in the queue as a different user, so condor_rm won't work
    *   $HOME doesn't exist on the remote end
    """
    cert = os.environ.get("GLEXEC_CLIENT_CERT")
    user = olduser = getpwuid(os.getuid())[0]
    if cert:
        log.info("switched to user %s with glexec (GLEXEC_CLIENT_CERT=%s)", user, cert)
        return

    cert = submit.get("X509UserProxy", os.environ.get("X509_USER_PROXY"))
    if not cert:
        log.debug("not switching users with glexec (no X509_USER_PROXY)")
        return

    env = os.environ.copy()
    env["GLEXEC_CLIENT_CERT"] = cert

    args = [sys.executable, getexec(sys.argv[0])] + sys.argv[1:]

    try:
        os.execvpe("glexec", args, env)
    except OSError:
        return

def hasx509(submit):
    x509 = os.environ.get("X509_USER_PROXY", "/tmp/x509up_u%s" % os.getuid())
    if os.path.exists(x509):
        # XXX: Can cause condor_submit to fail if a stale/expired proxy is
        # present.
        submit["X509UserProxy"] = x509
        return x509

def hascvmfs(submit):
    cmscvmfs = "/cvmfs/cms.hep.wisc.edu"
    try:
        attr = Popen(["attr", "-q", "-g", "revision", cmscvmfs], stdout=PIPE, stderr=PIPE)
        cvmfsrev = attr.stdout.read()
    except OSError:
        cvmfsrev = "0"
        
    submit["requirements"] = (submit.setdefault("requirements", "TRUE") +
        " && TARGET.UWCMS_CVMFS_Revision >= %s" % cvmfsrev)

def isexec(path):
    try:
        return os.path.isfile(path) and os.access(path, os.X_OK)
    except (OSError, IOError):
        return False

def getexec(path):
    if isexec(path):
        return path
    elif os.path.sep in path:
        return None

    base = os.path.basename(path)
    for dir in os.environ.get("PATH", "").split(os.pathsep):
        path = os.path.join(dir, base)
        if isexec(path):
            return path

def tail(file):
    while True:
        line = file.readline()
        if not line:
            sleep(.2)
        else:
            yield line

def monitor(stream):
    for line in stream:
        if line == "...\n":
            continue
        record = Record(*line.split(None, 4))
        log.debug("%s %s", record.id, record.message.rstrip())
        if "Job executing" in record.message:
            return record.id.strip("()")

@contextmanager
def tempdir(cleanup=True, **kwargs):
    tmp = mkdtemp(**kwargs)
    log.debug("created temporary directory %s", tmp)
    os.chdir(tmp)

    try:
        yield tmp
    finally:
        if cleanup:
            log.debug("cleaning up temporary directory %s", tmp)
            rmtree(tmp)

def template(out, context):
    out.write("\n".join("%s = %s" % (k, v) for k, v in context))
    out.write("\n")
    out.write("queue\n")

SUBMIT = dict(
    universe="vanilla",
    notification="never",
    log="log",
    transfer_executable="false",
    should_transfer_files="true",
    when_to_transfer_output="on_exit",
    getenv="true",
    requirements=(
        'TARGET.Arch == "X86_64" && '
        'TARGET.HasAFS_OSG && IsSlowSlot=!=true && '
        'TARGET.UidDomain == "hep.wisc.edu"'
    ),
)

Record = namedtuple("Record", "entry id date time message")

if __name__ == "__main__":
    try:
        sys.exit(main())
    except KeyboardInterrupt:
        sys.exit()
